${
    // Base Informations : https://github.com/frhagn/Typewriter/issues/275#issuecomment-429050839
    // Enable extension methods by adding using Typewriter.Extensions.*
    using Typewriter.Extensions.Types;
    using System.Text;
     Template(Settings settings)
    {
    settings.OutputExtension = ".ts";
    }
    // This custom function will take the type currently being processed and 
    // append a ? next to any type that is nullable
   string TypeFormatted(Property property)
    {
        var type = property.Type;
        var required = property.Attributes?.Any(o=>o.Name == "Required");
        var isRequired = (required.HasValue && required.Value);
        if (!isRequired && type.IsNullable)
            return "?";
       
        if (isRequired || type.IsGuid || (type.IsPrimitive && type.name != "string"))
            return "/*Required*/";
            
       
        return  $"?";
    }

    // Get the non primitive paramaters so we can create the Imports at the
    // top of the service
     void GenerateImportsForType(Typewriter.CodeModel.Type type, StringBuilder imports, HashSet<string> importMap)
    {
        if(type.TypeArguments.Any())
        {
            foreach(var subType in type.TypeArguments)
            {
                GenerateImportsForType(subType, imports, importMap);
            }
        }
        else if(type.IsDefined && !importMap.Contains(type.Name))
        {
            imports.AppendLine($"import {{ {type.Name} }} from './{type.Name}';");
            importMap.Add(type.Name);
        }
    }

    string FormulateClassImports(Class currentClass)
    {
        HashSet<string> importMap = new HashSet<string> { currentClass.Name };
        StringBuilder imports = new StringBuilder();
        foreach(var prop in currentClass.Properties)
        {
            GenerateImportsForType(prop.Type, imports, importMap);
        }

        return imports.ToString();
    }

    string FormulateInterfaceImports(Interface currentInterface)
    {
        HashSet<string> importMap = new HashSet<string> { currentInterface.Name };
        StringBuilder imports = new StringBuilder();
        foreach(var prop in currentInterface.Properties)
        {
            GenerateImportsForType(prop.Type, imports, importMap);
        }

        foreach(var method in currentInterface.Methods)
        {
            GenerateImportsForType(method.Type, imports, importMap);
            foreach(var p in method.Parameters)
            {
                GenerateImportsForType(p.Type, imports, importMap);
            }
        }

        return imports.ToString();
    }

    // $Classes/Enums/Interfaces(filter)[template][separator]
    // filter (optional): Matches the name or full name of the current item. * = match any, 
    // wrap in [] to match attributes or prefix with : to match interfaces or base classes.
    // template: The template to repeat for each matched item
    // separator (optional): A separator template that is placed between all templates e.g. 
    // $Properties[public $name: $Type][, ]
    
}
    // This File was auto-generated by TypeWriter. Any changes can be overriten if regenerated.
    // To modify this class, edit "1_ApiModels"
    // More info: http://frhagn.github.io/Typewriter/
    $Classes([ApiModel])[$FormulateClassImports
    export interface $Name {$Properties[
        $name$TypeFormatted: $Type;]
    }
    ]$Enums([ApiEnum])[// AutoGenerated File

export enum $Name {$Values[
    $Name = $Value][,]
}]$Interfaces([ApiModel])[// AutoGenerated File
$FormulateInterfaceImports
export interface $Name {$Properties[
    public $Name: $Type;
]$Methods[
    $Name($Parameters[$name: $Type][, ]): $Type;]
}]
